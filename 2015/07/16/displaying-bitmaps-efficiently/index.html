<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Displaying Bitmaps Efficiently · Hexo</title><meta name="description" content="Displaying Bitmaps Efficiently - lz55"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://lz55.github.io/atom.xml" title="Hexo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/2322512651/profile?topnav=1&amp;wvr=6&amp;is_all=1" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/helloyingying" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Displaying Bitmaps Efficiently</h1><div class="post-info">Jul 16, 2015</div><div class="post-content"><p><em>Google官方教程原文链接：<a href="http://developer.android.com/training/displaying-bitmaps/index.html" target="_blank" rel="external">http://developer.android.com/training/displaying-bitmaps/index.html</a></em></p>
<h1 id="1-高效加载大图"><a href="#1-高效加载大图" class="headerlink" title="1. 高效加载大图"></a>1. 高效加载大图</h1><h2 id="1-1-读取bitmap的dimension和type"><a href="#1-1-读取bitmap的dimension和type" class="headerlink" title="1.1 读取bitmap的dimension和type"></a>1.1 读取bitmap的dimension和type</h2><p>BitmapFactory提供了一些方法来通过不同的途径创建bitmap，比如：decodeByteArray(), decodeFile(), decodeResource()等。但是这些方法都试图为图片分配内存，因此很容易OOM。为此每种方法都有一个BitmapFactory.Options参数，为该参数设置inJustDecodeBounds为true就可以在对图片解码的时候不分配内存。bitmap会返回null，但是bitmap的outWidth，outHeight，和outMimeType却可以获得。</p>
<pre><code>BitmapFactory.Options options = new BitmapFactory.Options();
options.inJustDecodeBounds = true;
BitmapFactory.decodeResource(getResources(), R.id.myimage, options);
int imageHeight = options.outHeight;
int imageWidth = options.outWidth;
String imageType = options.outMimeType;
</code></pre><p>为了避免OOM，记得对图片解码之前检查一下dimension。</p>
<p>##1.2 将图片质量降级加载进内存<br>将一张1024<em>768的大图加载进一个128</em>96尺寸的ImageView是非常不值得的，为此我们需要将图片进行降级操作。在bitmap的configuration为ARGB_8888的情况下，吧BitmapFactory.Options的inSampleSize属性设置为4，就可以把一张2048<em>1536的图片降级为 512</em>384的，内存占用从12M降低为0.75M。</p>
<pre><code>public static int calculateInSampleSize(
        BitmapFactory.Options options, int reqWidth,     int reqHeight) {
    // Raw height and width of image
    final int height = options.outHeight;
    final int width = options.outWidth;
    int inSampleSize = 1;

    if (height &gt; reqHeight || width &gt; reqWidth) {

        final int halfHeight = height / 2;
        final int halfWidth = width / 2;

        // Calculate the largest inSampleSize value that is a power of 2 and keeps both
        // height and width larger than the requested height and width.
        while ((halfHeight / inSampleSize) &gt; reqHeight
                &amp;&amp; (halfWidth / inSampleSize) &gt; reqWidth) {
            inSampleSize *= 2;
        }
    }

    return inSampleSize;
}
</code></pre><p>总体的降级加载大图的流程如下所示：</p>
<pre><code>public static Bitmap decodeSampledBitmapFromResource(Resources res, int resId,
        int reqWidth, int reqHeight) {

    // First decode with inJustDecodeBounds=true to check dimensions
    final BitmapFactory.Options options = new BitmapFactory.Options();
    options.inJustDecodeBounds = true;
    BitmapFactory.decodeResource(res, resId, options);

    // Calculate inSampleSize
    options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);

    // Decode bitmap with inSampleSize set
    options.inJustDecodeBounds = false;
    return BitmapFactory.decodeResource(res, resId, options);
}
</code></pre><p>通过下面这行代码可以轻松地将一个大图变为一个100*100的小图。</p>
<pre><code>mImageView.setImageBitmap(
    decodeSampledBitmapFromResource(getResources(), R.id.myimage, 100, 100));
</code></pre><h1 id="2-避免在UI线程处理Bitmap"><a href="#2-避免在UI线程处理Bitmap" class="headerlink" title="2. 避免在UI线程处理Bitmap"></a>2. 避免在UI线程处理Bitmap</h1><p>一句话：只要不是从内存中读取图片并处理，都应该放到后台线程中，以免阻塞UI线程。</p>
<h2 id="2-1-使用AsyncTask"><a href="#2-1-使用AsyncTask" class="headerlink" title="2.1 使用AsyncTask"></a>2.1 使用AsyncTask</h2><p>不考虑并发问题的话可以使用AsyncTask这么处理：</p>
<pre><code>class BitmapWorkerTask extends AsyncTask&lt;Integer, Void, Bitmap&gt; {
    private final WeakReference&lt;ImageView&gt; imageViewReference;
    private int data = 0;

    public BitmapWorkerTask(ImageView imageView) {
        // Use a WeakReference to ensure the ImageView can be garbage collected
        imageViewReference = new WeakReference&lt;ImageView&gt;(imageView);
    }

    // Decode image in background.
    @Override
    protected Bitmap doInBackground(Integer... params) {
        data = params[0];
        return decodeSampledBitmapFromResource(getResources(), data, 100, 100));
    }

    // Once complete, see if ImageView is still around and set bitmap.
    @Override
    protected void onPostExecute(Bitmap bitmap) {
        if (imageViewReference != null &amp;&amp; bitmap != null) {
            final ImageView imageView = imageViewReference.get();
            if (imageView != null) {
                imageView.setImageBitmap(bitmap);
            }
        }
    }
}
</code></pre><p>使用弱引用可以很好地避免ImageVIew的内存泄露，当然，在任务执行完成的时候ImageView不能保证还在，因此需要检测引用是否为null。</p>
<p>##2.2 处理并发<br>像在ListView或GridView中，一般会启动非常多的后台线程来加载图片（从网络或者磁盘或者其他来源），这样就不能保证当线程任务执行完成的时候，响应的View没有被回收掉，更加不可能保证任务结束的顺序和开始的顺序一致。<br>这篇文章<a href="http://android-developers.blogspot.com/2010/07/multithreading-for-performance.html" target="_blank" rel="external"> Multithreading for Performance </a>讨论了一种并发问题的解决方案。让ImageView存储一个最近启动的AsyncTask的引用，当任务完成可以检测到它。创建一个Drawable的子类来存储工作任务的引用。在这里继承BitmapDrawable来显示一张占位图。</p>
<pre><code>static class AsyncDrawable extends BitmapDrawable {
    private final WeakReference&lt;BitmapWorkerTask&gt; bitmapWorkerTaskReference;

    public AsyncDrawable(Resources res, Bitmap bitmap,
            BitmapWorkerTask bitmapWorkerTask) {
        super(res, bitmap);
        bitmapWorkerTaskReference =
            new WeakReference&lt;BitmapWorkerTask&gt;(bitmapWorkerTask);
    }

    public BitmapWorkerTask getBitmapWorkerTask() {
        return bitmapWorkerTaskReference.get();
    }
}
</code></pre><p>在执行BitmapWorkTask之前，创建一个AsyncDrawable，并且将其与ImageView绑定。</p>
<pre><code>public void loadBitmap(int resId, ImageView imageView) {
    if (cancelPotentialWork(resId, imageView)) {
        final BitmapWorkerTask task = new BitmapWorkerTask(imageView);
        final AsyncDrawable asyncDrawable =
                new AsyncDrawable(getResources(), mPlaceHolderBitmap, task);
        imageView.setImageDrawable(asyncDrawable);
        task.execute(resId);
    }
}
</code></pre><p>cancelPotentialWork是一个用来检测是否有其他正在运行的后台任务和该ImageView绑定的工具函数，如果有的话将其cancel。</p>
<pre><code>public static boolean cancelPotentialWork(int data, ImageView imageView) {
    final BitmapWorkerTask bitmapWorkerTask = getBitmapWorkerTask(imageView);

    if (bitmapWorkerTask != null) {
        final int bitmapData = bitmapWorkerTask.data;
        // If bitmapData is not yet set or it differs from the new data
        if (bitmapData == 0 || bitmapData != data) {
            // Cancel previous task
            bitmapWorkerTask.cancel(true);
        } else {
            // The same work is already in progress
            return false;
        }
    }
    // No task associated with the ImageView, or an existing task was cancelled
    return true;
}
</code></pre><p>getBitmapWorkerTask()是一个用来获取和ImageView绑定的后台任务的工具函数。</p>
<pre><code>private static BitmapWorkerTask getBitmapWorkerTask(ImageView imageView) {
   if (imageView != null) {
       final Drawable drawable = imageView.getDrawable();
       if (drawable instanceof AsyncDrawable) {
           final AsyncDrawable asyncDrawable = (AsyncDrawable) drawable;
           return asyncDrawable.getBitmapWorkerTask();
       }
    }
    return null;
}
</code></pre><p>最后一步就是在onPostExecute()函数里面监测该任务是否被cancel掉，并且和当前ImageView的绑定task一致。</p>
<pre><code>class BitmapWorkerTask extends AsyncTask&lt;Integer, Void, Bitmap&gt; {
    ...

    @Override
    protected void onPostExecute(Bitmap bitmap) {
        if (isCancelled()) {
            bitmap = null;
        }

        if (imageViewReference != null &amp;&amp; bitmap != null) {
            final ImageView imageView = imageViewReference.get();
            final BitmapWorkerTask bitmapWorkerTask =
                    getBitmapWorkerTask(imageView);
            if (this == bitmapWorkerTask &amp;&amp; imageView != null) {
                imageView.setImageBitmap(bitmap);
            }
        }
    }
}
</code></pre><p>这种思路可以使用于任何View有回收可能的控件，比如ListView和GridView等。<br><strong><em><code>关键点就是解析完成的时候检测一下改线程或者task是否被cancel，并且是否属于当前ImageView</code></em></strong></p>
<p>#3. Cache Bitmap<br>这一部分主要是使用内存缓存和磁盘缓存。使用LruCache和DiskLruCache即可。详细内容参考<a href="http://developer.android.com/training/displaying-bitmaps/cache-bitmap.html" target="_blank" rel="external">http://developer.android.com/training/displaying-bitmaps/cache-bitmap.html</a>或者<a href="http://blog.csdn.net/guolin_blog/article/details/9316683" target="_blank" rel="external">http://blog.csdn.net/guolin_blog/article/details/9316683</a><br>需要注意的是，初始化DiskLruCache也需要进行磁盘操作，需要放入后台线程中进行。</p>
<h2 id="处理配置的改变"><a href="#处理配置的改变" class="headerlink" title="处理配置的改变"></a>处理配置的改变</h2><p>常见的配置的改变就是屏幕的旋转，如果将LruCache的引用储存在Activity中，当Activity重建的时候必须重新解析图片。可以使用Fragment的setRetainInstance(true)方法使Fragment在configuration change的时候保留实例，将LruCache的引用保存在Fragment中即可避免重新建立Cache。</p>
<pre><code>private LruCache&lt;String, Bitmap&gt; mMemoryCache;

@Override
protected void onCreate(Bundle savedInstanceState) {
    ...
    RetainFragment retainFragment =
            RetainFragment.findOrCreateRetainFragment(getFragmentManager());
    mMemoryCache = retainFragment.mRetainedCache;
    if (mMemoryCache == null) {
        mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) {
            ... // Initialize cache here as usual
        }
        retainFragment.mRetainedCache = mMemoryCache;
    }
    ...
}

class RetainFragment extends Fragment {
    private static final String TAG = &quot;RetainFragment&quot;;
    public LruCache&lt;String, Bitmap&gt; mRetainedCache;

    public RetainFragment() {}

    public static RetainFragment findOrCreateRetainFragment(FragmentManager fm) {
        RetainFragment fragment = (RetainFragment) fm.findFragmentByTag(TAG);
        if (fragment == null) {
            fragment = new RetainFragment();
            fm.beginTransaction().add(fragment, TAG).commit();
        }
        return fragment;
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setRetainInstance(true);
    }
}
</code></pre><p>#4 管理Bitmap内存</p>
<h2 id="4-1-Android2-3或者更低的版本"><a href="#4-1-Android2-3或者更低的版本" class="headerlink" title="4.1 Android2.3或者更低的版本"></a>4.1 Android2.3或者更低的版本</h2><p>在Android2.3或者更低的版本，当确定Bitmap不再使用的时候调用recycler()方法来释放内存，这时候就需要判断该Bitmap是否不再使用，可以使用引用计数的方法。</p>
<pre><code>private int mCacheRefCount = 0;
private int mDisplayRefCount = 0;
...
// Notify the drawable that the displayed state has changed.
// Keep a count to determine when the drawable is no longer displayed.
public void setIsDisplayed(boolean isDisplayed) {
    synchronized (this) {
        if (isDisplayed) {
            mDisplayRefCount++;
            mHasBeenDisplayed = true;
        } else {
            mDisplayRefCount--;
        }
    }
    // Check to see if recycle() can be called.
    checkState();
}

// Notify the drawable that the cache state has changed.
// Keep a count to determine when the drawable is no longer being cached.
public void setIsCached(boolean isCached) {
    synchronized (this) {
        if (isCached) {
            mCacheRefCount++;
        } else {
            mCacheRefCount--;
        }
    }
    // Check to see if recycle() can be called.
    checkState();
}

private synchronized void checkState() {
    // If the drawable cache and display ref counts = 0, and this drawable
    // has been displayed, then recycle.
    if (mCacheRefCount &lt;= 0 &amp;&amp; mDisplayRefCount &lt;= 0 &amp;&amp; mHasBeenDisplayed
            &amp;&amp; hasValidBitmap()) {
        getBitmap().recycle();
    }
}

private synchronized boolean hasValidBitmap() {
    Bitmap bitmap = getBitmap();
    return bitmap != null &amp;&amp; !bitmap.isRecycled();
}
</code></pre><p>##4.2 Android 3.0之后的Bitmap内存管理<br>Android3.0引入了BitmapFactory.Options.inBitmap属性，如果设置了该属性，解码的时候就会尝试重用之前图片分配的内存，但是这个条件比较严苛，Android4.4之前只有两个Bitmap大小相等并且inSampleSize=1才可以，Android4.4及之后，当新的Bitmap的字节数小于等于被重用Bitmap被分配的字节数时，可以进行复用。具体的代码实现见：<a href="http://developer.android.com/training/displaying-bitmaps/manage-memory.html#inBitmap" target="_blank" rel="external">http://developer.android.com/training/displaying-bitmaps/manage-memory.html#inBitmap</a></p>
</div></article></div></section><footer><div class="paginator"><a href="/2015/08/16/android-touch/" class="prev">PREV</a><a href="/2015/07/08/Android-Support-Library-翻译/" class="next">NEXT</a></div><div data-thread-key="2015/07/16/displaying-bitmaps-efficiently/" data-title="Displaying Bitmaps Efficiently" data-url="http://lz55.github.io/2015/07/16/displaying-bitmaps-efficiently/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"lz55"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2016 <a href="http://lz55.github.io">lz55</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>