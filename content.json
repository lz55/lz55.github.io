{"meta":{"title":"LZ55","subtitle":"先帝创业未办，而花光预算","description":null,"author":"LiuZhuang","url":"https://lz55.github.io"},"pages":[{"title":"tags","date":"2016-08-19T10:04:18.000Z","updated":"2016-08-19T10:04:18.000Z","comments":true,"path":"tags/index.html","permalink":"https://lz55.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"从零设计一款Android图片库","slug":"2016-12-24-LightImageLoader","date":"2016-12-24T06:11:02.000Z","updated":"2016-12-24T09:00:48.000Z","comments":true,"path":"2016/12/24/2016-12-24-LightImageLoader/","link":"","permalink":"https://lz55.github.io/2016/12/24/2016-12-24-LightImageLoader/","excerpt":"","text":"序言Android发展到今天，基础的框架已经非常完善，比如图片库，网络库，事件总线等，以图片库为例，常见的有Universal-Image-Loader, Picasso, Fresco, Glide。对于它们的使用，大部分程序员能很快地掌握，更优秀的能了解里面的实现原理，但是，从零设计一款图片库，则是一件挺复杂的事情了。下面我将以自己写的一个小型图片库为例，简单介绍下具体的设计思路。这个图片库严格意义上并不是从零开始，里面的一些实现借鉴了Picasso的思路，并做了一些的改进和扩展。 支持特性及使用方式使用方式借鉴了Picasso的链式调用： 1234567891011LightImageLoader.with(context) .load(url) .width(200) .height(200) .bitmapConfig(Bitmap.Config.RGB_565) .centerInside(false) .fade(true) .fadeTime(200) .placeholderDrawable(new ColorDrawable(Color.LTGRAY)) .errorResId(R.drawable.error) .into(imageView); 支持特性： 加载网络图片 合理的内存及磁盘空间利用 通过设定ImageView大小，展示样式使用更小的内存空间 支持渐入渐出 支持设置ErrorDrawable, PlaceHolderDrawable 自动判定Gif图，实现页面内播放，ImageView设置新的Bitmap或者回收掉的时候停止播放 支持任务暂停和恢复，可以轻松实现在页面滚动时候停止加载，页面静止的时候恢复加载 还有更高级的使用方式，支持注入不同的模块实现来进行扩展或者替换掉内置实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566LightImageLoader loader = new LightImageLoader.Builder(this) .setRequestTransformer(new RequestTransformer() &#123; @Override public Request transformRequest(Request request) &#123; return null; &#125; &#125;) .setCache(new Cache() &#123; @Override public Bitmap getFromMemory(String key) &#123; return null; &#125; @Override public Response getFromDisk(String key) &#123; return null; &#125; @Override public void put(String key, Response response) &#123; &#125; &#125;) .setDefaultConfig(Bitmap.Config.ARGB_8888) .addRequestHandler(new RequestHandler() &#123; @Override public boolean canHandleRequest(Request data) &#123; return false; &#125; @Override public Response load(Request request) throws IOException &#123; return null; &#125; @Override public int getRetryCount() &#123; return 0; &#125; @Override public boolean canRetry(boolean airplaneMode, NetworkInfo info) &#123; return false; &#125; &#125;) .setDownloader(new Downloader() &#123; @Nullable @Override public Response load(@NonNull Uri uri) throws IOException &#123; return null; &#125; @Override public void shutdown() &#123; &#125; &#125;) .build();loader.load(\"some image url\").into(imageView);//在列表滚动中停止加载recyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() &#123; @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) &#123; super.onScrollStateChanged(recyclerView, newState); if (newState == RecyclerView.SCROLL_STATE_DRAGGING) &#123; // pause LightImageLoader.pause(); &#125; else if (newState == RecyclerView.SCROLL_STATE_IDLE) &#123; // resume LightImageLoader.resume(); &#125; &#125;&#125;); Transformer来实现任务调度之前对request进行处理，可以实现对URL的动态替换 Cache是缓存逻辑的接口，可以注入外部特定的实现 Config代表加载图片的质量 RequestHandler接口可以实现图片加载模式的扩展，比如增加对资源文件中的图片加载模式，可以实现并注入RequestHandler接口，并针对合适的Request对canHandleRequest()方法返回true Downloader接口是真正实现网络请求的部分，外部可以通过注入自己的实现替换掉，这个特性特别适合业务方拥有自己的网络库的时候，可以用外部网络库替换掉内置的HttpUrlConnection实现的网络请求逻辑 整体架构","categories":[],"tags":[{"name":"Android 图片库","slug":"Android-图片库","permalink":"https://lz55.github.io/tags/Android-图片库/"}]},{"title":"ChocHttp系列之二：架构介绍","slug":"2016-08-24-choc-http-struture","date":"2016-08-24T05:17:23.000Z","updated":"2016-08-24T05:40:42.000Z","comments":true,"path":"2016/08/24/2016-08-24-choc-http-struture/","link":"","permalink":"https://lz55.github.io/2016/08/24/2016-08-24-choc-http-struture/","excerpt":"本篇是ChocHttp系列的第二篇，架构介绍，待完成~~","text":"本篇是ChocHttp系列的第二篇，架构介绍，待完成~~","categories":[],"tags":[]},{"title":"ChocHttp系列开篇：使用介绍","slug":"2016-05-22-chochttp_start","date":"2016-05-22T12:25:49.000Z","updated":"2017-10-16T06:58:34.000Z","comments":true,"path":"2016/05/22/2016-05-22-chochttp_start/","link":"","permalink":"https://lz55.github.io/2016/05/22/2016-05-22-chochttp_start/","excerpt":"","text":"自己动手做一个XX库本系列将包括： ChocHttp：基于HttpURLConnection的简单易用的Android网络库 ChocImage：简单易用的Android图片库 ChocStorage：高效易用的Android统一存储管理器 ChocBus：简单高效的事件总线 ChocHttpChocHttp是一个Android上的异步请求网络库，基于HttpURLConnection进行了封装，使用起来更加简单。 使用使用分为3步： 创建ChocHttp实例，并设置Config和JSON转换ConvertFactory（如果需要） 创建request 使用ChocHttp实例将第二步创建的request压入请求队列（好吧，其实就是调用一个方法） 实例代码： 1234567891011121314151617181920212223final BaseRequest request = new KeyValueRequest.Builder() .setUrl(&quot;http://http-caching-demo.herokuapp.com/?etag=true&amp;cache=true, &quot;) .setMethod(Method.GET) .build();ChocConfig config = new ChocConfig() .setConnectTimeOut(1000) .setRetryTimes(10) .setReadTimeOut(1000);ChocHttp chocHttp = new ChocHttp.Builder() .setConverterFactory(new GsonConverterFactory()) .setConfig(config) .build();chocHttp.asyncRequest(request, new ChocHttpListener() &#123; @Override public void onSuccess(BaseResponse rawResponse, Object pojoResponse) &#123; &#125; public void onError(int statusCode, String errorMessage) &#123; &#125; public void onCanceled(BaseRequest request) &#123; &#125;&#125;, OutPut.class); 一共有两种类型的Request可供选择，第一种参数是KEY-Value形式的，可以支持POST和GET，第二种参数是字符串形式的(可以进一步扩展为支持JSON字符串作为参数)，仅仅支持POST，二进制形式的有待开发。 TODO 支持PUT, DELETE, HEAD, TRACE, OPTIONS, PATCH方法。 支持文件上传和下载。","categories":[{"name":"ChocHttp","slug":"ChocHttp","permalink":"https://lz55.github.io/categories/ChocHttp/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://lz55.github.io/tags/Android/"},{"name":"Choc","slug":"Choc","permalink":"https://lz55.github.io/tags/Choc/"},{"name":"Http","slug":"Http","permalink":"https://lz55.github.io/tags/Http/"}]},{"title":"Android开发中的MVVM模式实践","slug":"2015-05-18-MVP-Pattern","date":"2016-05-22T05:19:25.000Z","updated":"2016-08-19T10:35:48.000Z","comments":true,"path":"2016/05/22/2015-05-18-MVP-Pattern/","link":"","permalink":"https://lz55.github.io/2016/05/22/2015-05-18-MVP-Pattern/","excerpt":"","text":"MVC, MVP and MVM一个典型的MVC模式如下图所示： MVC模式在实践中其实并不适合大规模Android应用的开发，因为Android从的设计上来说，activity/fragment更像是View层的组件和controller的结合，因为单纯的XML布局不能完成非常复杂的交互逻辑。工作项目由于一开始（2012年左右）的设计是MVC的，activity承担了view和controller的角色，工作中一个Activity耦合了展现层的逻辑和controller的逻辑后达到了4K+的行数，一个非常恐怖的数字。所以必须要对之进行解耦重构，其中MVP和MVVM引起了我们的注意，MVP模式见下图： MVP模式是从MVC派生出来的，但是它阻止了model和view的交流，使业务逻辑与展示解耦，MVP模式中，activity承担的是View的角色，Presenter和VIew互相依赖（为了解耦有的时候会使用接口和抽象类，这个其实有点MVVM的意思了），Presenter是View和Model的一个桥梁。Presenter和View是一一对应的，是View的一种抽象。MVP模式在解耦的层面做的不如MVVM彻底。关于MVP模式的讨论可以参见这篇文章. MVVM模式是在MVP模式上进一步解耦而派生出来的，见下图： MVVM和MVP模式的区别在于View对于ViewModel来说是透明的，ViewModel对于Model来说是透明的，ViewModel持有View的回调，Model持有ViewModel的回调，这样就实现View，ViewModel，Model的解耦。 更多关于MVC, MVP, MVVM模式的讨论可以看一下这篇文章. Demo以一个点击button发送网络请求，并对结果进行处理的demo为例。Activity的代码如下： 1234567891011121314151617181920212223242526272829public class MVVMDemoActivity extends ActionBarActivity implements IViewModelCallback &#123; MVVMDemoViewModel viewModel; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_mvvmdemo); viewModel = new MVVMDemoViewModel(this); findViewById(R.id.sendrequest).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; viewModel.action(); &#125; &#125;); &#125; @Override public void onDataReceive() &#123; //数据回来后进行视图的更新 &#125; @Override public void onError() &#123; //数据请求失败的时候做一些处理 &#125;&#125; 可以看到Activity中只负责了View层的展示逻辑，毫无接收参数设置参数等不属于View的操作。 ViewModel的代码如下： 1234567891011121314151617181920212223242526public class MVVMDemoViewModel implements IRequestCallback &#123; IViewModelCallback viewListener; DataRequestModel model; public MVVMDemoViewModel(IViewModelCallback viewListener) &#123; this.viewListener = viewListener; model = new DataRequestModel(this); &#125; public void action() &#123; //这里可以做一些参数的初始化操作 //...... model.sendRequest(); &#125; @Override public void onSuccess() &#123; viewListener.onDataReceive(); &#125; @Override public void onError() &#123; viewListener.onError(); &#125;&#125; View层对于ViewModel来说是透明的，ViewModel只负责对实现了IViewModelCallback类型进行操作。ViewModel可以做一些参数的获取和设置等既不属于View层也不是Model层面的操作，可以实现视图展示层和业务代码的解耦。 Model层的代码如下： 12345678910111213141516public class DataRequestModel &#123; private IRequestCallback IRequestCallback; public DataRequestModel(IRequestCallback IRequestCallback) &#123; this.IRequestCallback = IRequestCallback; &#125; public void sendRequest() &#123; //***模拟网络请求 //connecting... //网络请求成功 IRequestCallback.onSuccess(); //网络请求失败 IRequestCallback.onError(); &#125;&#125; View和ViewModel对于Model来说都是透明的，Model只负责进行网络请求，这个业务是非常独立的，可以说放之四海而皆准。 两个接口的代码如下： 123456789public interface IViewModelCallback &#123; void onDataReceive(); void onError();&#125;public interface IRequestCallback &#123; void onSuccess(); void onError();&#125; 总结可见，MVVM在比较大规模的Android应用的开发中可以做到一个很好的解耦，工作实践中也证实了这一点。","categories":[{"name":"Android","slug":"Android","permalink":"https://lz55.github.io/categories/Android/"}],"tags":[{"name":"MVVM","slug":"MVVM","permalink":"https://lz55.github.io/tags/MVVM/"},{"name":"解耦","slug":"解耦","permalink":"https://lz55.github.io/tags/解耦/"}]},{"title":"单例模式导致的Android内存泄露","slug":"2015-05-11-singleton-memory-leak","date":"2016-05-22T05:19:25.000Z","updated":"2016-08-19T11:26:07.000Z","comments":true,"path":"2016/05/22/2015-05-11-singleton-memory-leak/","link":"","permalink":"https://lz55.github.io/2016/05/22/2015-05-11-singleton-memory-leak/","excerpt":"","text":"问题项目开发中由于需要一个Util的单例化的存在，使用了单例模式，代码如下： 123456789101112131415161718192021public class SingletonDemo &#123; private static volatile SingletonDemo instance; private Context mContext; private SingletonDemo(Context context) &#123; this.mContext = context; &#125; public static SingletonDemo getInstance(Context context) &#123; if (instance == null) &#123; synchronized (SingletonDemo.class) &#123; if (instance == null) &#123; instance = new SingletonDemo(context); &#125; &#125; &#125; return instance; &#125;&#125; 关于如何正确的创建单例模式可以参考这篇文章，在这个地方我们仅仅讨论传进context有没有问题？ 详解答案当然是有问题的，由于这个地方的context是个强引用，而且是被静态变量持有。在java中静态变量实在类被load的时候分配内存，在类被卸载的时候销毁。可以说static变量的生命周期伴随着进程的诞生和销毁。在Android系统中，当我们启动一个app的时候，系统启动一个进程加载一个Dalvik虚拟机实例，来负责类的加载和卸载以及GC，也就是说静态变量伴随了app进程的整个生命周期，由于上例中的instance持有了context，所以被传进来的activity（或者service或broadcast）自然没有办法得到释放，也就造成了内存泄露。 解决办法其实这种需要单例的地方要仔细考虑好是否真的需要单例，因为在Android中静态变量其实是很不靠谱的，静态变量依附于进程，而Android在资源充足的时候是不会杀进程的，也就是说资源不足的情况下，进程随时可能被杀掉然后再具有资源的时候重启，那样存在静态变量里的值就很不靠谱了。如果说非得这么做不可，OK，使用context.getApplicationContext()，可以看一下Android developer上的解释： There is normally no need to subclass Application. In most situation, static singletons can provide the same functionality in a more modular way. If your singleton needs a global context (for example to register broadcast receivers), the function to retrieve it can be given a Context which internally uses Context.getApplicationContext() when first constructing the singleton. Application在Android程序中是一种单例式的存在，它伴随了整个应用的始终，所以使用Application的context自然不会造成内存泄露了。 番外 在Android开发中组件之间传递参数尽量符合Android规范使用bundle来进行传递，不要使用static，因为static是依附于进程模型的，而Android中的组件如Activity，Service等是可以运行在不同的进程的。另外，由于进程的不安全，static中存储的值也自然不太可靠了。 关于内存泄露的检查工具可以参考这篇文章的介绍。","categories":[{"name":"Android","slug":"Android","permalink":"https://lz55.github.io/categories/Android/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://lz55.github.io/tags/设计模式/"},{"name":"内存泄露","slug":"内存泄露","permalink":"https://lz55.github.io/tags/内存泄露/"}]},{"title":"Android Support Library","slug":"2015-07-08-Android-Support-Library-翻译","date":"2016-05-22T05:19:25.000Z","updated":"2016-08-19T10:37:59.000Z","comments":true,"path":"2016/05/22/2015-07-08-Android-Support-Library-翻译/","link":"","permalink":"https://lz55.github.io/2016/05/22/2015-07-08-Android-Support-Library-翻译/","excerpt":"","text":"（原文链接：http://android-developers.blogspot.com/2015/05/android-design-support-library.html） 由于更新了整个Android用户体验的崭新设计语言material design的诞生，Android 5.0（代号：Lollipop）成为史上最重要的一个版本。从详细的规范开始学习material design 是个不错的方案，但这对于开发者，尤其是哪些考虑前向兼容的，这是个不小的挑战。有了最新的Android Design支持库的帮助，我们在其中给大家提供了许多非常重要的material design组件，并且支持Android2.1以上所有的系统版本，开发者可以使用抽屉导航组件，输入文本的浮动标签，floating action button，snackbar，tabs，并且可以使用一个支持手势和滚动的框架来将其组合使用。 Navigation View:对于用户尤其是首次使用某个APP的用户而言，抽屉导航极大程度上降低了在APP内进行统一的个性化和导航的难度。通过提供一个抽屉导航所需的框架和从菜单资源中构建导航条目的功能，NavigationView使得创建抽屉导航变得非常简单。 开发者可以像使用DrawerLayout的抽屉导航布局一样使用NavigationView，如下所示： 12345678910111213141516&lt;android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\"&gt; &lt;!-- your content layout --&gt; &lt;android.support.design.widget.NavigationView android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:layout_gravity=\"start\" app:headerLayout=\"@layout/drawer_header\" app:menu=\"@menu/drawer\"/&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 请注意NavigationView的两个属性：app:headerLayout用来控制头部布局，这是可选的一个属性；app:menu控制用来产生各种导航条目的菜单资源（可以在运行时更新）。NavigationView可以在大于API21的设备中和状态栏进行正确的交互。最简单抽屉菜单可以是一系列Checkable的菜单项的集合。 1234567891011&lt;group android:checkableBehavior=\"single\"&gt; &lt;item android:id=\"@+id/navigation_item_1\" android:checked=\"true\" android:icon=\"@drawable/ic_android\" android:title=\"@string/navigation_item_1\"/&gt; &lt;item android:id=\"@+id/navigation_item_2\" android:icon=\"@drawable/ic_android\" android:title=\"@string/navigation_item_2\"/&gt;&lt;/group&gt; 为了确保用户明确知道自己选中了什么，被选中的抽屉导航的条目会高亮显示。同样可以在抽屉导航中使用subheaders来将条目分割为不同的组合。 1234567891011121314&lt;item android:id=\"@+id/navigation_subheader\" android:title=\"@string/navigation_subheader\"&gt; &lt;menu&gt; &lt;item android:id=\"@+id/navigation_sub_item_1\" android:icon=\"@drawable/ic_android\" android:title=\"@string/navigation_sub_item_1\"/&gt; &lt;item android:id=\"@+id/navigation_sub_item_2\" android:icon=\"@drawable/ic_android\" android:title=\"@string/navigation_sub_item_2\"/&gt; &lt;/menu&gt;&lt;/item&gt; 通过使用setNavigationItemSelectedListener()可以为抽屉导航设置OnNavigationItemSelectedListener 监听器，当某个条目被选中的时候会产生回调。回调函数中可以得到被点击的MenuItem对象，有了该对象就可以控制选中事件，改变选中状态，加载新的内容，在程序中关闭抽屉导航，或者做其他任何你想要的操作。 输入文本的浮动标签：(Floating labels for editing text)在Material Design中，即便简单如EditText也得到了一定程度上的改进。在EditText中，当输入第一个字符之后，提示文本便会被隐藏掉。但是现在开发者可以使用TextInputLayout布局来包装EditText，这样当输入文本的时候，提示文本就会变成一个浮动在EditText上的标签，确保用户永远明确他们想要什么。 通过调用setError()方法，开发者还可以在EditText的下面显示错误信息。 Floating Action Button：Floating Action Button是在用户界面上指示着最主要操作的圆形按钮。设计库中的FloatingActionButton通过使用主题中colorAccent着色，给开发者提供一种统一的实现。 为了处理FloatingActionButton和其他组件的视觉连贯性特别严苛的情况，除了正常的大小，FloatingActionButton还支持设置最小的尺寸（fabSize=”mini”）。FloatingActionButton继承自ImageView所以开发者可以使用android:src或其他任何方法比如setImageDrawable来控制FloatingActionButton的图案。 Snackbar：当需要为一个操作提供轻量级的快速的反馈的时候，Snackbar是一个非常完美的选择。Snackbar以一个可选的简单地动作在屏幕或内容文字的底部出现。超过了设定的给定时长之后Snackbar自动地按照设定动画从屏幕消失。另外，在设定时长到期之前，用户也可以将Snackbar滑出屏幕。由于Snackbar具有通过滑动或其他动作和用户交互的能力，因此它比另一种轻量级的反馈机制Toast更加强大，并且开发者可以发现它们的API是相似的。 1234Snackbar .make(parentLayout, R.string.snackbar_text, Snackbar.LENGTH_LONG) .setAction(R.string.snackbar_action, myOnClickListener) .show(); // Don’t forget to show! 应该注意的是make()方法的第一个参数是View的一个对象，Snackbar会尝试寻找一个以其底部作为锚点的合适的父类布局。 Tabs：在App中通过Tabs来切换不同的View并不是material design新提出的概念，但是它却是在APP中用来组织不同分类信息的最高等级的导航模式（比如，音乐的不同体裁）。 设计库中的TabLayout既实现了View宽度等距离分割的fix tabs，也实现了大小不一，可以水平滑动的scrollable tabs。Tabs可以在代码中添加： 12TabLayout tabLayout = ...;tabLayout.addTab(tabLayout.newTab().setText(\"Tab 1\")); 然而，如果开发者使用ViewPager进行Tab之间的水平分页，可以直接通过PagerAdapter的getPageTitle()方法然后调用setupWithViewPager()方法将二者联系起来，从而直接创建Tab。这保证了Tab被选中时更新ViewPager并且ViewPager切换的时候更新Tab。 CoordinatorLayout，手势和滚动：特殊的视觉效果只是material design一个方面，手势操作也是一个符合material design应用非常重要的一部分。Material Design在包括了如触摸波浪效果和有意义的转换动画的同时，还引入了CoordinatorLayout，这个布局可以为字类视图之间的触摸事件提供另一种层面上的控制，再设计库中的很多组件都进行了利用。 CoordinatorLayout和floating action button:这两种控件有一个非常棒的使用方式，将floating action button作为CoordinatorLayout的子元素，并且将CoordinatorLayout传递给Snackbar的make()方法，FloatingActionButton利用CoordinatorLayout提供的额外的回调，可以在Snackbar显示的时候自动上移，并在Snackbar消失的时候自动回归原来的位置，这样，Snackbar就不是浮在floating action button上面了，这在所有Android3.0及以上的设备中都可以实现，不需要多余的代码。在CoordinatorLayout中，layoutut_anchor属性和layout_anchorGravity属性配合，可以用来设定浮动视图（比如floating action button）之间的相对位置。 CoordinatorLayout和app bar:另一个关于CoordinatorLayout非常主要的用法就是与app bar（之前的action bar）和滚动策略的配合使用。Toolbar可以更加简单地定制这个APP中标志性的部分的外观和交互，而许多开发者可能已经开始使用它了。而设计库将这个提升了一个等级：通过AppBarLayout，Toolbar和其他视图（比如提供Tab的TabLayout）可以在标记了ScrollingViewBehavior的兄弟视图中和滚动事件交互。因此，开发者可以像这样创建一个布局： 123456789101112131415161718192021222324 &lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;! -- Your Scrollable View --&gt; &lt;android.support.v7.widget.RecyclerView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" /&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;android.support.v7.widget.Toolbar ... app:layout_scrollFlags=\"scroll|enterAlways\"&gt; &lt;android.support.design.widget.TabLayout ... app:layout_scrollFlags=\"scroll|enterAlways\"&gt; &lt;/android.support.design.widget.AppBarLayout&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 这样，当用户滚动RecyclerView的时候AppBarLayout可以根据子类视图的滚动标志来控制他们进入屏幕和离开屏幕的方式。这些滚动标志包括：• scroll：所有想要滑出屏幕的视图都应该设置这个标志，对于那些未设置的视图，会固定在屏幕顶端。• enterAlways：这个标志确保了向下滚动的时候视图可见，使quick return模式可用。• enterAlwaysCollapsed：当一个视图被设置了minHeight并且使用了这个标志之后，那么这个视图只会按照最小的高度进入屏幕，当可滚动的视图到达顶部的时候，它会展开完整的高度。• exitUntilCollapsed：设置了这个标志之后，视图在离开屏幕之前会先滚动到折叠状态（最小高度）。 注意：所有使用scroll这个标志的视图都应该在不使用这个标志的视图之前声明，保证所有的视图从顶部离开屏幕，将固定不动的视图留在下面。 Collapsing Toolbar：如果直接在AppTabLayout中添加Toolbar可以通过设置enterAlwaysCollapsed和exitUntilCollapsed滚动标志来控制折叠效果，但是这并没有对不同元素交互时的细节控制能力。因此开发者可以使用CollapsingToolbarLayout： 12345678910111213&lt;android.support.design.widget.AppBarLayout android:layout_height=\"192dp\" android:layout_width=\"match_parent\"&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_scrollFlags=\"scroll|exitUntilCollapsed\"&gt; &lt;android.support.v7.widget.Toolbar android:layout_height=\"?attr/actionBarSize\" android:layout_width=\"match_parent\" app:layout_collapseMode=\"pin\"/&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt;&lt;/android.support.design.widget.AppBarLayout&gt; 通过对CollapsingToolbarLayout设置app:layout_collapseMode=”pin”可以保证当视图被折叠的时候Toolbar固定在屏幕顶端。更棒的是，当CollspsingToolBarLayout和Toolbar一起使用的时候，当布局完全可见的时候标题会变大，并且在布局折叠的时候转变到默认大小。需要注意的是，应该为CollapsingToolbarLayout调用setTitle()方法设置标题，而不是对Toolbar设置。除了固定视图以外，还可以使用app:layoutCollapseMode=”parallax”（还可以通过app:layout_collapseParallaxMultiplier=”0.7”来设置视差率），来实现视差滚动（比如说在CollapsingToolbarLayout中添加ImageView作为兄弟视图）。这种情景配合CollapsingToolbarLayout 的app:contentScrim=”?attr/colorPrimary” 属性会在视图折叠的时候产生非常棒的效果。 CoordinatorLayout 和个性化视图需要注意的非常重要的一点就是CoordinatorLayout并不知道FloatingActionButton或者AppBarLayout的作用，它仅仅以Coordinator.Behavior的形式提供一个额外的API接口，来更好的控制子类View之间的触摸事件和手势，并且通过onDependentViewChanged()来声明依赖和接受回调。视图可以通过在代码中设置CoordinatorLayout.DefaultBehavior(YourView.Behavior.class) 或者在布局文件中设置app:layout_behavior=”com.example.app.YourView$Behavior”属性来控制默认的表现样式。Android从框架级别保证了任意视图和CoordinatorLayout交互的可能性。 Available Now：设计库现在就可以使用了，只要保证在SDK管理器中更新了Android 支持库即可。只要添加下面一行依赖： compile &apos;com.android.support:design:22.2.0&apos; 需要注意的是，设计库依赖了support v4和AppCompat支持库，当使用设计库的时候会自动包含二者。这些新的组件在Android Studio的布局编辑器的设计视图中是可见的，这给了开发者一个更加方便的预览这些新的组件的方式。","categories":[{"name":"Android","slug":"Android","permalink":"https://lz55.github.io/categories/Android/"}],"tags":[{"name":"Android，Material Design","slug":"Android，Material-Design","permalink":"https://lz55.github.io/tags/Android，Material-Design/"}]},{"title":"Displaying Bitmaps Efficiently","slug":"2015-07-16-displaying-bitmaps-efficiently","date":"2016-05-22T05:19:25.000Z","updated":"2016-08-19T11:32:53.000Z","comments":true,"path":"2016/05/22/2015-07-16-displaying-bitmaps-efficiently/","link":"","permalink":"https://lz55.github.io/2016/05/22/2015-07-16-displaying-bitmaps-efficiently/","excerpt":"","text":"Google官方教程原文链接：http://developer.android.com/training/displaying-bitmaps/index.html 1. 高效加载大图1.1 读取bitmap的dimension和typeBitmapFactory提供了一些方法来通过不同的途径创建bitmap，比如：decodeByteArray(), decodeFile(), decodeResource()等。但是这些方法都试图为图片分配内存，因此很容易OOM。为此每种方法都有一个BitmapFactory.Options参数，为该参数设置inJustDecodeBounds为true就可以在对图片解码的时候不分配内存。bitmap会返回null，但是bitmap的outWidth，outHeight，和outMimeType却可以获得。 123456BitmapFactory.Options options = new BitmapFactory.Options();options.inJustDecodeBounds = true;BitmapFactory.decodeResource(getResources(), R.id.myimage, options);int imageHeight = options.outHeight;int imageWidth = options.outWidth;String imageType = options.outMimeType; 为了避免OOM，记得对图片解码之前检查一下dimension。 1.2 将图片质量降级加载进内存将一张1024768的大图加载进一个12896尺寸的ImageView是非常不值得的，为此我们需要将图片进行降级操作。在bitmap的configuration为ARGB_8888的情况下，吧BitmapFactory.Options的inSampleSize属性设置为4，就可以把一张20481536的图片降级为 512384的，内存占用从12M降低为0.75M。 12345678910111213141516171819202122public static int calculateInSampleSize( BitmapFactory.Options options, int reqWidth, int reqHeight) &#123; // Raw height and width of image final int height = options.outHeight; final int width = options.outWidth; int inSampleSize = 1; if (height &gt; reqHeight || width &gt; reqWidth) &#123; final int halfHeight = height / 2; final int halfWidth = width / 2; // Calculate the largest inSampleSize value that is a power of 2 and keeps both // height and width larger than the requested height and width. while ((halfHeight / inSampleSize) &gt; reqHeight &amp;&amp; (halfWidth / inSampleSize) &gt; reqWidth) &#123; inSampleSize *= 2; &#125; &#125; return inSampleSize;&#125; 总体的降级加载大图的流程如下所示： 123456789101112131415public static Bitmap decodeSampledBitmapFromResource(Resources res, int resId, int reqWidth, int reqHeight) &#123; // First decode with inJustDecodeBounds=true to check dimensions final BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeResource(res, resId, options); // Calculate inSampleSize options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight); // Decode bitmap with inSampleSize set options.inJustDecodeBounds = false; return BitmapFactory.decodeResource(res, resId, options);&#125; 通过下面这行代码可以轻松地将一个大图变为一个100*100的小图。 12mImageView.setImageBitmap( decodeSampledBitmapFromResource(getResources(), R.id.myimage, 100, 100)); 2. 避免在UI线程处理Bitmap一句话：只要不是从内存中读取图片并处理，都应该放到后台线程中，以免阻塞UI线程。 2.1 使用AsyncTask不考虑并发问题的话可以使用AsyncTask这么处理： 123456789101112131415161718192021222324252627class BitmapWorkerTask extends AsyncTask&lt;Integer, Void, Bitmap&gt; &#123; private final WeakReference&lt;ImageView&gt; imageViewReference; private int data = 0; public BitmapWorkerTask(ImageView imageView) &#123; // Use a WeakReference to ensure the ImageView can be garbage collected imageViewReference = new WeakReference&lt;ImageView&gt;(imageView); &#125; // Decode image in background. @Override protected Bitmap doInBackground(Integer... params) &#123; data = params[0]; return decodeSampledBitmapFromResource(getResources(), data, 100, 100)); &#125; // Once complete, see if ImageView is still around and set bitmap. @Override protected void onPostExecute(Bitmap bitmap) &#123; if (imageViewReference != null &amp;&amp; bitmap != null) &#123; final ImageView imageView = imageViewReference.get(); if (imageView != null) &#123; imageView.setImageBitmap(bitmap); &#125; &#125; &#125;&#125; 使用弱引用可以很好地避免ImageVIew的内存泄露，当然，在任务执行完成的时候ImageView不能保证还在，因此需要检测引用是否为null。 2.2 处理并发像在ListView或GridView中，一般会启动非常多的后台线程来加载图片（从网络或者磁盘或者其他来源），这样就不能保证当线程任务执行完成的时候，响应的View没有被回收掉，更加不可能保证任务结束的顺序和开始的顺序一致。这篇文章 Multithreading for Performance 讨论了一种并发问题的解决方案。让ImageView存储一个最近启动的AsyncTask的引用，当任务完成可以检测到它。创建一个Drawable的子类来存储工作任务的引用。在这里继承BitmapDrawable来显示一张占位图。 1234567891011121314static class AsyncDrawable extends BitmapDrawable &#123; private final WeakReference&lt;BitmapWorkerTask&gt; bitmapWorkerTaskReference; public AsyncDrawable(Resources res, Bitmap bitmap, BitmapWorkerTask bitmapWorkerTask) &#123; super(res, bitmap); bitmapWorkerTaskReference = new WeakReference&lt;BitmapWorkerTask&gt;(bitmapWorkerTask); &#125; public BitmapWorkerTask getBitmapWorkerTask() &#123; return bitmapWorkerTaskReference.get(); &#125;&#125; 在执行BitmapWorkTask之前，创建一个AsyncDrawable，并且将其与ImageView绑定。 123456789public void loadBitmap(int resId, ImageView imageView) &#123; if (cancelPotentialWork(resId, imageView)) &#123; final BitmapWorkerTask task = new BitmapWorkerTask(imageView); final AsyncDrawable asyncDrawable = new AsyncDrawable(getResources(), mPlaceHolderBitmap, task); imageView.setImageDrawable(asyncDrawable); task.execute(resId); &#125;&#125; cancelPotentialWork是一个用来检测是否有其他正在运行的后台任务和该ImageView绑定的工具函数，如果有的话将其cancel。 1234567891011121314151617public static boolean cancelPotentialWork(int data, ImageView imageView) &#123; final BitmapWorkerTask bitmapWorkerTask = getBitmapWorkerTask(imageView); if (bitmapWorkerTask != null) &#123; final int bitmapData = bitmapWorkerTask.data; // If bitmapData is not yet set or it differs from the new data if (bitmapData == 0 || bitmapData != data) &#123; // Cancel previous task bitmapWorkerTask.cancel(true); &#125; else &#123; // The same work is already in progress return false; &#125; &#125; // No task associated with the ImageView, or an existing task was cancelled return true;&#125; getBitmapWorkerTask()是一个用来获取和ImageView绑定的后台任务的工具函数。 12345678910private static BitmapWorkerTask getBitmapWorkerTask(ImageView imageView) &#123; if (imageView != null) &#123; final Drawable drawable = imageView.getDrawable(); if (drawable instanceof AsyncDrawable) &#123; final AsyncDrawable asyncDrawable = (AsyncDrawable) drawable; return asyncDrawable.getBitmapWorkerTask(); &#125; &#125; return null;&#125; 最后一步就是在onPostExecute()函数里面监测该任务是否被cancel掉，并且和当前ImageView的绑定task一致。 12345678910111213141516171819class BitmapWorkerTask extends AsyncTask&lt;Integer, Void, Bitmap&gt; &#123; ... @Override protected void onPostExecute(Bitmap bitmap) &#123; if (isCancelled()) &#123; bitmap = null; &#125; if (imageViewReference != null &amp;&amp; bitmap != null) &#123; final ImageView imageView = imageViewReference.get(); final BitmapWorkerTask bitmapWorkerTask = getBitmapWorkerTask(imageView); if (this == bitmapWorkerTask &amp;&amp; imageView != null) &#123; imageView.setImageBitmap(bitmap); &#125; &#125; &#125;&#125; 这种思路可以使用于任何View有回收可能的控件，比如ListView和GridView等。关键点就是解析完成的时候检测一下改线程或者task是否被cancel，并且是否属于当前ImageView 3. Cache Bitmap这一部分主要是使用内存缓存和磁盘缓存。使用LruCache和DiskLruCache即可。详细内容参考http://developer.android.com/training/displaying-bitmaps/cache-bitmap.html或者http://blog.csdn.net/guolin_blog/article/details/9316683需要注意的是，初始化DiskLruCache也需要进行磁盘操作，需要放入后台线程中进行。 处理配置的改变常见的配置的改变就是屏幕的旋转，如果将LruCache的引用储存在Activity中，当Activity重建的时候必须重新解析图片。可以使用Fragment的setRetainInstance(true)方法使Fragment在configuration change的时候保留实例，将LruCache的引用保存在Fragment中即可避免重新建立Cache。 1234567891011121314151617181920212223242526272829303132333435363738private LruCache&lt;String, Bitmap&gt; mMemoryCache;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; ... RetainFragment retainFragment = RetainFragment.findOrCreateRetainFragment(getFragmentManager()); mMemoryCache = retainFragment.mRetainedCache; if (mMemoryCache == null) &#123; mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123; ... // Initialize cache here as usual &#125; retainFragment.mRetainedCache = mMemoryCache; &#125; ...&#125;class RetainFragment extends Fragment &#123; private static final String TAG = \"RetainFragment\"; public LruCache&lt;String, Bitmap&gt; mRetainedCache; public RetainFragment() &#123;&#125; public static RetainFragment findOrCreateRetainFragment(FragmentManager fm) &#123; RetainFragment fragment = (RetainFragment) fm.findFragmentByTag(TAG); if (fragment == null) &#123; fragment = new RetainFragment(); fm.beginTransaction().add(fragment, TAG).commit(); &#125; return fragment; &#125; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setRetainInstance(true); &#125;&#125; 4 管理Bitmap内存4.1 Android2.3或者更低的版本在Android2.3或者更低的版本，当确定Bitmap不再使用的时候调用recycler()方法来释放内存，这时候就需要判断该Bitmap是否不再使用，可以使用引用计数的方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445private int mCacheRefCount = 0;private int mDisplayRefCount = 0;...// Notify the drawable that the displayed state has changed.// Keep a count to determine when the drawable is no longer displayed.public void setIsDisplayed(boolean isDisplayed) &#123; synchronized (this) &#123; if (isDisplayed) &#123; mDisplayRefCount++; mHasBeenDisplayed = true; &#125; else &#123; mDisplayRefCount--; &#125; &#125; // Check to see if recycle() can be called. checkState();&#125;// Notify the drawable that the cache state has changed.// Keep a count to determine when the drawable is no longer being cached.public void setIsCached(boolean isCached) &#123; synchronized (this) &#123; if (isCached) &#123; mCacheRefCount++; &#125; else &#123; mCacheRefCount--; &#125; &#125; // Check to see if recycle() can be called. checkState();&#125;private synchronized void checkState() &#123; // If the drawable cache and display ref counts = 0, and this drawable // has been displayed, then recycle. if (mCacheRefCount &lt;= 0 &amp;&amp; mDisplayRefCount &lt;= 0 &amp;&amp; mHasBeenDisplayed &amp;&amp; hasValidBitmap()) &#123; getBitmap().recycle(); &#125;&#125;private synchronized boolean hasValidBitmap() &#123; Bitmap bitmap = getBitmap(); return bitmap != null &amp;&amp; !bitmap.isRecycled();&#125; 4.2 Android 3.0之后的Bitmap内存管理Android3.0引入了BitmapFactory.Options.inBitmap属性，如果设置了该属性，解码的时候就会尝试重用之前图片分配的内存，但是这个条件比较严苛，Android4.4之前只有两个Bitmap大小相等并且inSampleSize=1才可以，Android4.4及之后，当新的Bitmap的字节数小于等于被重用Bitmap被分配的字节数时，可以进行复用。具体的代码实现见：http://developer.android.com/training/displaying-bitmaps/manage-memory.html#inBitmap","categories":[{"name":"Android","slug":"Android","permalink":"https://lz55.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://lz55.github.io/tags/Android/"},{"name":"Bitmap","slug":"Bitmap","permalink":"https://lz55.github.io/tags/Bitmap/"},{"name":"Memory","slug":"Memory","permalink":"https://lz55.github.io/tags/Memory/"}]},{"title":"Java Weak References","slug":"2015-10-11-java-weak-references","date":"2016-05-22T05:19:25.000Z","updated":"2016-08-19T11:30:30.000Z","comments":true,"path":"2016/05/22/2015-10-11-java-weak-references/","link":"","permalink":"https://lz55.github.io/2016/05/22/2015-10-11-java-weak-references/","excerpt":"","text":"强引用一般对Java对象的构造用的就是强引用: Object o = new Object(); 除非对象被置为null，否则虚拟机即使OOM也不会回收掉强引用。 软引用软引用的一般用法： 12Object o = new Object();SoftReference&lt;Object&gt; softReference = new SoftReference&lt;Object&gt;(o); 只有内存不足的时候才能被GC回收掉，如果构造函数中传入了ReferenceQueue，当该引用指向的对象被标记为垃圾的时候，这个引用对象会自动地加入到引用队列里面，我们可以通过ReferenceQueue来跟踪被回收的软引用，并在适当时候将其清除掉。 弱引用弱引用的一般用法： 12Object o = new Object();WeakReference&lt;String&gt; abcWeakRef = new WeakReference&lt;String&gt;(o); 当一个对象只被弱引用引用的时候就会被GC回收掉，比如将上面的代码添加一句：o = null;同样的，当一个对象被标记为垃圾的时候会加入到引用队列。下面通过一个例子来验证一下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class ReferenceTest &#123; private static ReferenceQueue&lt;VeryBig&gt; rq = new ReferenceQueue&lt;VeryBig&gt;(); public static void checkQueue() &#123; Reference&lt;? extends VeryBig&gt; ref = null; while ((ref = rq.poll()) != null) &#123; if (ref != null) &#123; System.out.println(\"In queue: \" + ((VeryBigWeakReference) (ref)).id); &#125; &#125; &#125; public static void main(String args[]) &#123; int size = 3; LinkedList&lt;WeakReference&lt;VeryBig&gt;&gt; weakList = new LinkedList&lt;WeakReference&lt;VeryBig&gt;&gt;(); for (int i = 0; i &lt; size; i++) &#123; weakList.add(new VeryBigWeakReference(new VeryBig(\"Weak \" + i), rq)); System.out.println(\"Just created weak: \" + weakList.getLast()); &#125; // 将第二个弱引用对象变为强引用 VeryBig strongRef = weakList.get(1).get(); // 检查一遍 checkQueue(); System.gc(); try &#123; // 休息几秒，让上面的垃圾回收线程运行完成 Thread.currentThread().sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 在检查一遍 checkQueue(); // 检查对象 for (int i = 0; i &lt; size; i++) &#123; if (weakList.get(i).get() == null) &#123; System.out.println(\"obj \" + i + \" is null!\"); &#125; &#125; // 检查是否还在引用队列 checkQueue(); &#125; private static class VeryBig &#123; public String id; // 占用空间,让线程进行回收 byte[] b = new byte[2 * 1024]; public VeryBig(String id) &#123; this.id = id; &#125; protected void finalize() &#123; System.out.println(\"Finalizing VeryBig \" + id); &#125; &#125; private static class VeryBigWeakReference extends WeakReference&lt;VeryBig&gt; &#123; public String id; public VeryBigWeakReference(VeryBig big, ReferenceQueue&lt;VeryBig&gt; rq) &#123; super(big, rq); this.id = big.id; &#125; protected void finalize() &#123; System.out.println(\"Finalizing VeryBigWeakReference \" + id); &#125; &#125;&#125; 运行程序： 123456789Just created weak: ReferenceTest$VeryBigWeakReference@7440e464Just created weak: ReferenceTest$VeryBigWeakReference@49476842Just created weak: ReferenceTest$VeryBigWeakReference@78308db1Finalizing VeryBig Weak 2Finalizing VeryBig Weak 0In queue: Weak 0In queue: Weak 2obj 0 is null!obj 2 is null! OK，当调用System.gc();之前ReferenceQueue里面并没有数据，调用之后发现引用对象2和1的finalize()方法被执行，并且对象2和1被添加到了引用队列，调用引用队列的poll()方法即将其清除掉，最后一遍的checkQueue()没有发现任何对象引用。 非常重要的一点是当将weakRef.get()指向的对象被赋值给一个强引用时，在该强引用被置为null之前，都不会作为弱引用被管理。 虚引用好吧，其实一直不知道虚引用有什么卵用，因为它太弱了，弱到根本无法引用。根本没有办法通过get获得它指向的对象。 其实弱引用还是有一点作用的，它的唯一作用就是当其指向的对象被回收之后，自己被加入到引用队列，用作记录该引用指向的对象已被销毁。他可以让你知道这个对象什么时候被移除掉，比如你在一个Android APP只能加载一张超大图（先不考虑图片的压缩问题），在加载下一张之前你需要确定系统已经将上一张大图片占据的内存回收掉，这时候就可以使用虚引用并结合ReferenceQueue来做判断。 后记该文章主要参考了：https://weblogs.java.net/blog/2006/05/04/understanding-weak-references 代码参考了http://blog.csdn.net/mazhimazh/article/details/19752475 并做了一些改动。 关于ReferenceQueue还有很多可以说的，可以参考http://hongjiang.info/java-referencequeue/","categories":[{"name":"Java","slug":"Java","permalink":"https://lz55.github.io/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://lz55.github.io/tags/java/"},{"name":"Weak Reference","slug":"Weak-Reference","permalink":"https://lz55.github.io/tags/Weak-Reference/"}]},{"title":"Android touch事件处理流程","slug":"2015-08-16-android-touch","date":"2016-05-22T05:19:25.000Z","updated":"2016-08-19T10:34:14.000Z","comments":true,"path":"2016/05/22/2015-08-16-android-touch/","link":"","permalink":"https://lz55.github.io/2016/05/22/2015-08-16-android-touch/","excerpt":"","text":"序言工作中遇到一个业务场景：对WebView做一个封装，能根据webview某个点的透明度决定事件是被消费掉还是透传下去。有两个思路，一个是继承，一个是引用，能继承当然是最好的，但是有的时候也许根本没办法继承webview，比如为了资源回收等问题系统使用同一个webview组件，但不巧的是，为了模块解耦，在别的模块根本拿不到webview的类，只能通过bridge拿到一个引用，这个就必须通过引用来实现了。无论哪种方法都涉及到了touch事件的处理流程，简单梳理下。 View对touch事件的处理流程对Touch事件的处理涉及四个重要的方法： dispatchTouchEvent(MotionEvent event)setOnTouchListener(OnTouchListener l)onTouchEvent(MotionEvent event) 先了解一下dispatchTouchEvent(MotionEvent event): 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Pass the touch screen motion event down to the target view, or this * view if it is the target. * * @param event The motion event to be dispatched. * @return True if the event was handled by the view, false otherwise. */public boolean dispatchTouchEvent(MotionEvent event) &#123; // If the event should be handled by accessibility focus first. if (event.isTargetAccessibilityFocus()) &#123; // We don't have focus or no virtual descendant has it, do not handle the event. if (!isAccessibilityFocusedViewOrHost()) &#123; return false; &#125; // We have focus and got the event, then use normal event dispatch. event.setTargetAccessibilityFocus(false); &#125; boolean result = false; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(event, 0); &#125; final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Defensive cleanup for new gesture stopNestedScroll(); &#125; if (onFilterTouchEventForSecurity(event)) &#123; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; if (!result &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); &#125; // Clean up after nested scrolls if this is the end of a gesture; // also cancel it if we tried an ACTION_DOWN but we didn't want the rest // of the gesture. if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123; stopNestedScroll(); &#125; return result;&#125; 代码略长，但是和重点部分是下面的这几句：123456789101112if (onFilterTouchEventForSecurity(event)) &#123; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; 这段代码先判断了通过setOnTouchEvent(OnTouchListener l) 设置的onTouchListener, 如果listener不为空，View 的点击状态是ENABLE，并且onTouchListener.onTouch 返回true，那么给Result置为true。代码接着判断Result为false，才会执行View 自身的onTouchEvent 方法，如果onTouchEvent 返回true则将Result置为true。如果经过这两步Result为true，代表当前事件已经被消费掉了，触发下一次事件。否则是不会触发下一次事件的，典型的表现就是action_down被触发而action_move, action_up不会得到响应。 也就是说：touch事件会首先触发dispatchTouchEvent方法，并且如果外围设置了onTouchListener会先执行onTouchListener的onTouch方法，只有当onTouch返回false才会执行自身的onTouchEvent方法。 看一下 onTouchEvent(MotionEvent event):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148/** * Implement this method to handle touch screen motion events. * &lt;p&gt; * If this method is used to detect click actions, it is recommended that * the actions be performed by implementing and calling * &#123;@link #performClick()&#125;. This will ensure consistent system behavior, * including: * &lt;ul&gt; * &lt;li&gt;obeying click sound preferences * &lt;li&gt;dispatching OnClickListener calls * &lt;li&gt;handling &#123;@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK&#125; when * accessibility features are enabled * &lt;/ul&gt; * * @param event The motion event. * @return True if the event was handled, false otherwise. */public boolean onTouchEvent(MotionEvent event) &#123; final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; if (event.getAction() == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)); &#125; if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123; // take focus if we don't have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; if (prepressed) &#123; // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true, x, y); &#125; if (!mHasPerformedLongPress) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; performClick(); &#125; &#125; &#125; if (mUnsetPressedState == null) &#123; mUnsetPressedState = new UnsetPressedState(); &#125; if (prepressed) &#123; postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); &#125; else if (!post(mUnsetPressedState)) &#123; // If the post failed, unpress right now mUnsetPressedState.run(); &#125; removeTapCallback(); &#125; break; case MotionEvent.ACTION_DOWN: mHasPerformedLongPress = false; if (performButtonActionOnTouchDown(event)) &#123; break; &#125; // Walk up the hierarchy to determine if we're inside a scrolling container. boolean isInScrollingContainer = isInScrollingContainer(); // For views inside a scrolling container, delay the pressed feedback for // a short period in case this is a scroll. if (isInScrollingContainer) &#123; mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) &#123; mPendingCheckForTap = new CheckForTap(); &#125; mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); &#125; else &#123; // Not inside a scrolling container, so show the feedback right away setPressed(true, x, y); checkForLongClick(0); &#125; break; case MotionEvent.ACTION_CANCEL: setPressed(false); removeTapCallback(); removeLongPressCallback(); break; case MotionEvent.ACTION_MOVE: drawableHotspotChanged(x, y); // Be lenient about moving outside of buttons if (!pointInView(x, y, mTouchSlop)) &#123; // Outside button removeTapCallback(); if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; // Remove any future long press/tap checks removeLongPressCallback(); setPressed(false); &#125; &#125; break; &#125; return true; &#125; return false;&#125; 代码的逻辑还是非常清晰的，在该方法中主要是做了Event的action产生click，longPress等事件。 ViewGroup对touch事件的处理ViewGroup和Touch事件相关的方法比起View多了一个onInterceptTouchEvent(MotionEvent ev)，而这个方法代码非常简单：123public boolean onInterceptTouchEvent(MotionEvent ev) &#123; return false;&#125; 但是它的注释却长的吓人： 用一段测试程序来说明这些流程，假设有一个ViewGroup比如FrameLayout，里面包含了一个Button。 Activity的代码： 123456789101112131415findViewById(R.id.touch_btn).setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; Log.d(\"MyButton\", \"OnTouchListener\"); return false; &#125; &#125;); findViewById(R.id.touch_frame_layout).setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; Log.d(\"MyFrameLayout\", \"OnTouchListener\"); return false; &#125; &#125;); MyButton的代码： 12345678910111213141516171819202122232425public class MyButton extends Button &#123; public MyButton(Context context) &#123; super(context); &#125; public MyButton(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public MyButton(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; Log.d(\"MyButton\", \"onTouchEvent\"); return super.onTouchEvent(event); &#125; @Override public boolean dispatchTouchEvent(MotionEvent event) &#123; Log.d(\"MyButton\", \"dispatchTouchEvent\"); return super.dispatchTouchEvent(event); &#125;&#125; MyFrameLayout的代码如下: 12345678910111213141516171819202122232425262728293031public class MyTouchFrameLayout extends FrameLayout &#123; public MyTouchFrameLayout(Context context) &#123; super(context); &#125; public MyTouchFrameLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public MyTouchFrameLayout(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; Log.d(\"MyFrameLayout\", \"onInterceptTouchEvent\"); return super.onInterceptTouchEvent(ev); &#125; @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; Log.d(\"MyFrameLayout\", \"dispatchTouchEvent\"); return super.dispatchTouchEvent(ev); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; Log.d(\"MyFrameLayout\", \"onTouchEvent\"); return super.onTouchEvent(event); &#125;&#125; 点击button时事件的传递流程如下： action_down MyFrameLayout﹕ dispatchTouchEvent MyFrameLayout﹕ onInterceptTouchEvent MyButton﹕ dispatchTouchEvent MyButton﹕ OnTouchListener MyButton﹕ onTouchEventaction_upMyFrameLayout﹕ dispatchTouchEventMyFrameLayout﹕ onInterceptTouchEventMyButton﹕ dispatchTouchEventMyButton﹕ OnTouchListenerMyButton﹕ onTouchEvent 也就是说任何一个action都会先触发父类布局的dispatchTouchEvent -&gt; onInterceptTouchEvent, 但是FrameLayout的onTouchEvent方法并没有被调用。 如果将onInterceptTouchEvent的返回值改为true，测试结果如下所示： MyFrameLayout﹕ dispatchTouchEvent MyFrameLayout﹕ onInterceptTouchEvent MyFrameLayout﹕ OnTouchListener MyFrameLayout﹕ onTouchEvent 可以发现执行到了FrameLayout的onTouchEvent方法，但是MyButton的所有方法都没有被执行到。 去ViewGroup的dispatchTouchEvent方法一探究竟（代码过长只说部分代码和结论，有兴趣直接看源码）： 结论： 在dispatchTouchEvent方法中会首先执行onInterceptTouchEvent判断是否拦截事件，如果onInterceptTouchEvent返回false表示不拦截则将倒序遍历子View（布局中后添加的View会先做出响应），并调用dispatchTransformedTouchEvent方法递归调用子View的dispatchTouchEvent方法，如果子View为Viewgroup并且没有被拦截那么递归调用dispatchTouchEvent，如果子View为View调用onTouchEvent方法。 如果onInterceptTouchEvent返回true，表示将事件拦截下来不往子View传递，调用自身的onTouchEvent事件。 基于继承关系的PenetrateWebView（可穿透WebView）明白了touch事件在View中的传递流程，使用继承来实现PenetrateWebView也就非常简单了。 首先有一个工具方法来获取某一点的alpha值： 123456789private static int getAlphaOfViewPoint(View view, int x, int y) &#123; view.setDrawingCacheEnabled(true); Bitmap bmp = view.getDrawingCache(true); int pixel = bmp.getPixel(x, y); int alpha = Color.alpha(pixel); TMDebugLog.logv(\"pop_layer.point_alpha \", alpha+\"\"); view.destroyDrawingCache(); return alpha;&#125; 然后再自定义WebView中重写onTouchEvent方法： 12345678910111213141516 public boolean onTouchEvent(MotionEvent event) &#123; try &#123; if (event.getY() &lt; 0 || event.getX() &lt; 0) return super.onTouchEvent(event); //如果某点的alpha值小于等于阈值，将事件透传下去 //反之将事件消费掉 if (getAlphaOfViewPoint(this, (int) event.getX(), (int) event.getY()) &lt;= mPenetrateAlpha) &#123; return false; &#125; return super.onTouchEvent(event); &#125; catch (Throwable e) &#123; e.printStackTrace(); return super.onTouchEvent(event); &#125;&#125; 基于继承关系的PenetrateWebView实现起来还是非常容易的，下面讨论一下基于引用关系的PenetrateWebView。 基于引用关系的PenetrateWebView当没有办法继承的时候我首先想到的是设置OnTouchListener，但是onTouch返回true虽然将事件消费掉了，但是就不会执行onTouchEvent方法，也就无法产生click事件，整个WebView失去了交互的能力。返回false更加没有任何意义了，还是没办法控制onTouchEvent。于是想到了在WebView的外部嵌套一层布局实现事件的拦截，一开始没搞清楚ViewGroup中事件的传递流程，在dispatchTouchEvent和onTouchEvent中写逻辑，发现还是没办法实现很好的控制，在阅读了touch相关的代码后，使用下面的方式实现了PenetrateWebView。 123456789101112131415161718@Overridepublic boolean onInterceptTouchEvent(MotionEvent event) &#123; try &#123; if (event.getY() &lt; 0 || event.getX() &lt; 0) return super.onTouchEvent(event); // 如果该点的alpha小于等于阈值，在该布局中拦截下事件，交给上层布局处理，onTouchEvent事件会被执行，onTouchEvent始终返回false，将事件透传下去 // 如果该点的alpha大于阈值，将事件交给子View处理，onTouchEvent事件并不会被执行，将事件拦截下来 return getAlphaOfViewPoint(this, (int) event.getX(), (int) event.getY()) &lt;= mPenetrateAlpha; &#125; catch (Throwable e) &#123; e.printStackTrace(); return false; &#125;&#125;@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; return false;//当该方法被执行的时候，将事件交给父类布局去处理&#125; 总结 View设置OnTouchListener之后，如果onTouch返回true那么onTouchEvent方法不会被执行。 click事件是在onTouchEvent方法中产生的。 ViewGroup中Touch事件传递是从外到内的，子View倒序遍历。 ViewGroup中onInterceptTouchEvent方法返回false的时候不会执行该ViewGroup的onTouchEvent方法，返回true则会执行。","categories":[{"name":"Android","slug":"Android","permalink":"https://lz55.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://lz55.github.io/tags/Android/"},{"name":"touch","slug":"touch","permalink":"https://lz55.github.io/tags/touch/"}]}]}